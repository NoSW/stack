

### 6个图形数据标准

* GKS(Graphics Kernal System)提供了在应用程序和图形输入输出设备之间的功能接口，定义了一个独立于语言的图形核心系统
* GKSM是图形核心标准GKS用于保存信息的一种机制
* 计算机图形元文件标准 CGM
* 计算机图形接口标准CGI (Computer Graphics Interface) 
* 基本图形交换规范标准IGES
* DXF数据接口 是AutoCAD系统的图形数据文件，虽然不是标准，但由于AutoCAD系统的普遍应用，使其成为事实上的数据交换标准。
* 产品数据表达与交换标准STEP

### 图形输入&交互技术

> * 请求方式是在应用程序的控制下工作的
> * 在取样方式下，允许输入设备和应用程序同时工作 
> * 在事件方式下，由输入设备来初始化数据输入，控制数据处理进程 
> * 一旦有一种逻辑输入设备以及特定的物理设备已被设成相应的方式后，即可用来输入数据或命令。一个应用程序同时可在几种输入控制方式下应用几个不同的输入设备来进行工作

哪6类设备？

* 定位器（locator）

  > ​	直接、间接（数字化仪、鼠标器、游戏棒、轨迹球、光标键、键盘字符串）
  >
  > 橡皮条技术（线段、矩形、圆、棱锥）
  >
  > 拖曳技术
  >
  > 菜单技术
  >
  > 

* 描画设备（stroke）

* 定值设备（Valuator）

  > ​	键盘/旋钮 输入， 刻度尺比例尺、旋转盘

* 选择设备 （choice）

* 拾取设备（Pick）

  > ​	指定名称法、特征点法、外接矩形法、分类法、直接法
  >
  > 网格化
  >
  > 吸附技术

* 字符串设备（string）

### 光栅图形学

光栅显示器、光栅图形的概念？走样、反走样、消隐的概念？

> ​	一个象素矩阵。光栅显示器上的任何一个图形都是一些具有一种或多种 颜色和灰度象素的集合。由于象素个数、颜色、灰度等级都是有限的， 而且象素是有大小的，所以光栅图形只是实际图形的近似
>
> 光栅显示器上显示的图形
>
> 在光栅图形中，非水平和垂直的直线用象素集合表示时呈锯齿状的现象
>
> 用于减少或消除走样的技术
>
> 为了使计算机图形能够真实地反映现实世界的遮挡现象，必须把隐藏的部分从图形中消除

直线段是扫描转换算法

* 数值微分法

  > ![image-20211231204348062](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204348062.png)

* 中点画线法

  > ![image-20211231204335247](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204335247.png)
  >
  > F(x,y) = ax+by+c=0
  >
  > 计算a=y0-y1, b=x1-x0 c=带入已知点计算
  >
  > d0 = 2*F(P0) =2a+b   d1=2\*a(d>0时取的增量)  d2=2\*(a+b)（d<0时取的增量）

* Bresenham算法

  > ​	![image-20211231204314342](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204314342.png)
  >
  > d0=0, d = d+k 保证0<= d < 1
  >
  > d>= 0.5, 即e>=0时，y+1
  >
  > d<0.5 即e<0时，y
  >
  > ps：可用2e消除小数，ppt上的例子没有这样做

圆弧的扫描转换算法

* 简单方程法（直角坐标、极坐标）

* 中点画圆法

  > ​	![image-20211231204454532](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204454532.png)
  >
  > 可改写为仅用整数、仅用加法的算法

* 圆的Bresenham算法

  > ​	![image-20211231204616124](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204616124.png)

椭圆的扫描转换算法

> ​	![image-20211231204757607](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231204757607.png)

* 简单方程法（直角坐标、极坐标）
* 椭圆的中点算法

多边形区域填充算法

* 多边形的表示方法哪两种？

  > 顶点序列，直观、几何意义强，占内存少，易于几何变换，不可直接面着色
  >
  > 点阵，丢失几何信息，便于帧缓冲器表示，面着色所需的图形表示形式

* 多边形的类别哪三种？

  > ​	凹 凸 内环（内环不可相交）

* 多边形填充——扫描线算法

  > ​	![image-20211231205104693](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231205104693.png)

* 多边形填充——边界标志算法(无需排序，更适合硬件实现，速度更快)

* 多边形填充——种子填充算法

  > 点阵形式，边界一种颜色，内部一种颜色
  >
  > 4向连通区域、8向连通区域
  >
  > 简单、递归、耗时、耗内存，效率不高





字符的三种类别

* 点阵式字符。位图
* 矢量式字符。点坐标序列。存储空间小、美观、易变换
* 方向编码式字符。若干个方向编码（如8方向编码）。易填入帧缓冲器，接收特定的变换（放大缩小，45度旋转），很难任意角度旋转。
* 轮廓字型技术原理？（点阵字符压缩技术：黑白段压缩（不失真还原快但不方便）、部件压缩（压缩比大，不保证质量）、轮廓字型法(好！)）



直线段裁剪算法

* Cohen-Sutherland算法：4位tbrl编码 -> c1&&c2 ==0（内，取）->c1&c2 != 0（外，弃） ->求交点，重复操作
* 中点分割算法：P0->P1找进入点A；P1->P0找进入点B，AB之间为可见部分
* 梁友栋—Barskey算法：太难了，不会！



多边形裁剪算法

* Sutherland-Hodgeman算法：一次用窗口的一条边裁剪多边形（记忆规则：输出交点(如果存在)+终点(如果可见)）
* 字符串裁剪
  * 字符串包含的字符个数+字符大小、间隔、轨迹 -> 外包盒
  * 精度：字符串精度、字符精度、像素精度



反走样

* 提高分辨率：原理？缺点？

  > ​	显示器分辨率提高一倍，直线经过两倍的象素，**锯齿也增加一倍**，但同时**每个阶梯的宽度也减小了一倍**，显示出的直线段看起来就平直光滑了一些
  >
  > 这种反走样方法是以**4倍的存储器代价和扫描转换时间**获得的。因此，增加分辨率虽然简单，但是不经济的方法，而且它也只能减轻而不能消除锯齿问题

* 区域采样：相交区域的面积大小决定像素的亮度值。如何计算面积比？子像素的离散简化计算法k/n？

* 加权区域采样。非加权的两个缺点?加权的做法，亮度值取决于到像素中心的距离。预置的二维加权表用于离散计算来加速积分运算

  > ​	缺点一，与相交面积成正比，与相交区域落在像素内的位置无关，仍有锯齿
  >
  > 缺点二，沿理想方向的相邻像素有时会有较大灰度差
  >
  > 加权表，如3x3 (1/16)*[[1 2 1 ] [2 4 2] [1 2 1]]

### 曲线

曲线表示方法

* 显示、隐式

  > 会与坐标轴相关，会斜率无穷大、非平面曲线，曲面难以表示出来，不便于编程计算

* 参数（CG常用于表示曲线曲面）

  > ​	几何不变性、更多的参数导致自由度大、易于几何变换，便于处理无穷斜率、便于从低纬拓展到高维空间，t属于0-1界定曲线曲面范围更简单，易于矢量计算矩阵计算

几个关于曲线的定义

* 切矢量，该点的切线T(s)=dp(t)/ds(t)

* 法矢量，该点的N(s)=dT(s)/ds

  > ​	副法矢为B=T×N。主法矢N+副法矢叫法平面，N+T叫密切平面，B+T叫从切平面

* 位置矢量，该点的位置坐标P(t)

* 曲率，d$\phi$/ds

  > ​	曲率的倒数叫曲率半径，曲率越大越弯曲

* 挠率，d$\theta$/ds，$\theta$是两个点的密切平面的夹角

参数曲面片？

双三次参数曲面的代数形式！

简单回旋面？直纹面？



* 线性插值
* 抛物线（二次）插值
* 逼近：最小二乘法
* 拟合=插值和逼近的统称
* 光顺：二阶几何连续、曲率变化小、不存在多余拐点（二阶导为0，大于0是凹，小于0是凸）和奇异点



* 参数区间的规格化

  > ​	任意区间转到[0,1]

* 参数曲线的代数和几何形式

  > ​	![image-20220101221020198](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101221020198.png)
  >
  > 转为
  >
  > ![image-20220101221042974](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101221042974.png)
  >
  > ![image-20220101222307884](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101222307884.png)!!!!!!!!1



* 连续性：C0/G0（值）, C1/ G1（切矢）, C2, G2（曲率，也就是C1/G1基础上的二阶导）

贝塞尔曲线

* 基函数

  > ​	正性、端点性质、权重和为1，对称性、递推性
  >
  > ![image-20220101224259877](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101224259877.png)
  >
  > 求导，可解最大值在t=i/n时取到
  >
  > 升阶公式，不会！
  >
  > 对t从0积分到1等于1/(n+1)    

* 性质

  > 凸包性：贝塞尔曲线上的每个点都是Pi的加权平均，即Pi的凸线性组合
  >
  > 坐标不变性：贝塞尔曲线的位置和形状不依赖于坐标系的选择，只与顶点有关。
  >
  > 变差缩减性：平面内任意直线与贝塞尔曲线的交点数目不多于与其特征多边形的交代数目，（贝塞尔曲线比特征多边形的折线更光滑）
  >
  > 仿射不变性![image-20220102144017172](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220102144017172.png)
  >
  > 

  

* 一次两次三次贝塞尔曲线形式

  > ![image-20220102144124876](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220102144124876.png)
  >
  > ![image-20220102144153516](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220102144153516.png)

  > ![image-20220102144202519](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220102144202519.png)

  > ![image-20220102144216260](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220102144216260.png)
  >
  > 递归形式（de Casteljau算法，标准算法，计算简单）
  >
  > ![image-20220101225647588](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101225647588.png)
  >
  > P_i^0 是控制点，P_0^n是具有参数t的带点

### 图形变换

叉乘

> ​	![image-20211231212217765](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231212217765.png)



齐次坐标表示。优点？

> 提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法
>
> 可以表示无穷远的点？

几何变换——窗口区->视图区 矩阵公示，不会！

二维图形变换

* 平移：3x3矩阵的前两行的第三列
* 缩放：3x3矩阵的左上角的2x2矩阵的对角线
* 旋转：3x3矩阵的左上角的2x2矩阵
* 对称：3x3矩阵的左上角的2x2矩阵
* 错切：3x3矩阵的左上角的2x2矩阵的斜对角线（对角线全1）
* 复合：矩阵相乘，先作用的放最右边
* 关于任意点：先平移到原点在平移回去  T(x,y)QT(-x,-y)

三维图形

* 平移：类似二维

* 缩放：类似二维

* 旋转：类似二维

* 对称：类似二维

* 错切：类似二维

* 复合：类似二维

* 关于任意点：类似二维

* 关于任意轴AB旋转：T_A R_x R_y R_z R_y-1 R_x-1 T_A-1

  > ​	或者![image-20211231223946568](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231223946568.png)
  >
  > Rotating $\mathbf{v}$ around $\mathbf{u}$ by $\mathbf{\theta}$ 
  > $$
  > \mathbf{v'=cos({\theta})v+(1-cons(\theta))(u\cdot v)u+sin(\theta)(u\times v)}
  > $$

方向数：直线与三个坐标轴的夹角余弦 {A,B,C}

> ​	![image-20211231214606883](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20211231214606883.png)

三视图变换，Oxz正，Oyz侧，Oxy俯

斜平行投影，不会！

透视变换矩阵

![image-20220103212621135](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220103212621135.png)



### 消隐

概念

> ​	消除投影产生的二义性，绘制时消除被遮挡的线和面

三种分类？

> ​	物体空间的消隐（光线投射，Roberts），对场景中的每个面与其他每个面判断
>
> 图像空间的消隐（Z-buffer， 扫描线，warnack），对每个像素进行判断
>
> 物体空间和图像空间的消隐（画家算法）：先在物体空间计算可见性优先级，再在图像空间中生成消隐图



* 平面对直线段的遮挡判断算法？

* 画家算法

  > 简单、**但**只能处理互不相交的面

* Z-buffer

  > ​	简单灵活、利于硬件实现、**但**占用空间大，没有利用图形的相关性和连续性。可用区间扫描做改进，在每一区间只计算一次深度值，并且不需要Z缓冲器

* 区域子空间分割算法（Warnack算法）

  > 如四叉树。涉及到如何判断窗口与多边形的关系
  >
  > ![image-20220101203332170](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20220101203332170.png)
  >
  > * 判断内含&相交：借助裁剪算法
  > * 判断包围和分离
  >   * 转角检查法：360°是包含；0°是分离
  >   * 区域编码法：窗口外分成8个区域，检查顶点是否均有对于区域编号

* 简单情形直接显示

  > ​	所有多边形均与窗口分离，只有一个多边形与窗口相交、有一个最靠前的多边形包围了窗口等

* 光线投射法

  > ​	复杂度类似z-buffer，但可以用包围盒、空间分割技术来加速计算


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>