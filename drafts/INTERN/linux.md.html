**进程创建**

`fork()`产生的子进程会完全复制父进程的状态

* 写时拷贝技术，优化了`fork()`的开销

> 而windowns中的`CreateProcess(...)`，需要提供大量进程的配置参数

然后执行`exec()`，注：`exec()`是一系列接口的组合，比如其中的

`int execve(const char *pathname, char *const argv[], char *const envp[])`

* 二进制可执行文件的路径
* 进程执行需要的参数
* 为进程定义的环境变量

先把二进制可执行文件的数据段和代码段载入的当前进程的地址空间中，重新初始化栈和堆（采用随机初始化可以防攻击），将pc设置为代码段定义的入口点，该入口点最终会调用`main()`。



**进程监控**

`wait()`有很多变种。如`waitpid(pid_t pid, int * wstatus, int options)`

如果父进程没有调用`wait`操作或者没来得及调用，那么这种进程叫僵尸进程。当父进程创建了大量的子进程而没有wait，那么僵尸进程会迅速占据可用的pid。如果父进程退出，该父进程的僵尸进程会被`init`进程通过调用`wait`来回收。

---

进程组（pg）：是进程的集合，可以把软件产生的信号，发送到该组的每个进程。（`fork()`产生的子进程默认与父进程同组。但`init`的`pid = gid = sid = 1`，直接由内核管理的进程 `gid = sid = 0`

会话（session）：进程组的集合，比如shell由前台进程组和后台进程组等组成



`fork()`的不足

* 内部实现越来越复杂，和其他模块（进程、内存管理）耦合度过高

* 性能差。原进程状态越多，拷贝开销越大，有的程序就连建立内存映射都有耗费大量时间。

  * 可用`vfork()`改进。在限定场景下，`vfork() + exec() = fork() + exec()`，但它不会为子进程单独建立地址空间，而是让父子共享同一地址空间(节省了内存空间的拷贝)。为了保证正确性，会阻塞父进程，直至子进程调用`exec()`或者退出为止。，但也无法避免安全问题。
  * 或者灵活性差，但性能好的`posix_spwan()`，可以看作`fork()+exec()`，因为提供的控制参数数目的限制，表达能力有限，灵活性不足。执行时间与原进程内存无关

* 安全性不足。可以多次尝试，让服务器创建与父进程相同内存空间和内存数据的子进程，完成攻击

  * 可用更精密的`rfork()/clone()`来解决。

    ```c
    #include <sched.h>
    
    int clone(int (*fn)(void*), void *stack, int flags, void *args, ...);
    ```

    * 通过`flags`表面允许程序指定不需要复制的部分。如：设定`CLONE_VM`，来避免复制内存，父子使用相同的地址空间，达到和`vfork()`类似的效果。
    * `void *stack`表明了子进程的进程栈位置，解决了父子共享地址空间时栈冲突的问题
    * 另外两个参数是进程创建完将要执行的函数及其参数，执行完后，子进程将终止并返回

Linux和Windows采用的是一对一模型，并限制ULT的数量

**线程本地存储（TLS）**：指的是线程会**存储一些用户态相关的数据**，比如全局变量`count`，那么通过TLS，可实现对同一变量`count`的私有拷贝的访问。另外TLS的寻址方式是，把TLS的起始地址保存到FS寄存器中（每个线程的FS寄存器的值不相同），再加上`count`在TLS的偏移量（每个TLS的偏移量相同），这样看起来每个线程访问`count`都是FS寄存器+偏移量在TLS中寻址，但实际访问的内存位置并不相同

**线程创建**

如Linux的POSIX线程库中

```c
#include <pthread.h>

int pthread_create(pthread_t *thread,
					const pthread_attr_t *attr,
					void *(*start_routine) (void *),
					void *args)
    
void pthread_exit(void *retval);// 会被隐式调用（线程的返回值等于线程主函数的返回值），如果显示调用可以设置线程的返回值。

int pthread_yield(void); // yield the CPU, set ready status.

int pthread_join(pthrad_t thread, void **retval); // 会把线程`thread`的返回值从被等待的线程即`thread`的内存拷贝到当前线程指定的地址

// 挂起
// 1. 等待固定的时间
# include <unistd.h>
unsigned int sleep(unsigned int seconds); // yield() 类似于sleep(0)
unsigned int nanosleep(unsigned int nanoseconds);

// 2. 等待某事件
int pthread_cond_wait(pthread_cond_t *restrict cond,
                     pthread_mutex_t *restrict mutex); // 会让线程等待在参数`cond`上，内核会使线程被挂起，当其他线程使用`pthread_conf_signal`操作同一个变量`cond`时，内核会协助把挂起的线程唤醒为ready状态。

int pthread_cond_timedwait(pthread_cond_t *restrict cond,
						pthread_mutex_t *restrict mutex,
						const struct timespec *restrict abstime); // 是前两者的结合，等待到具体事件或超时就唤醒
```

是通过`clone()`传入大量控制参数，创建出一个从属于原进程、与原进程共享大量数据结构、拥有私有栈的实例，也就是一个线程。

Linux的负载均衡（层级调度）

* 调度域：拥有相同特性的CPU集合，这些核心见可以进行负载均衡
* 调度组：一个调度域保存一个或多个调度组。调度组是一个调度域内进行负载均衡的整体单位。
* 自下向上的方式进行负载均衡
  * 越高层级间进行负载均衡，开销越大，所以Linux在不同层级的调度域设置了不同的负载均衡出发频率和阈值（只有当两个调度域的负载之差大于阈值才触发）。显然每一层的参数设置不尽相同。



八股文：

* Linux上执行ls，OS都干了啥
  * shell不断询问是否有输入
  * 发现通配符，解释通配符
  * 再PATH中搜索ls命令
    * 存在，就fork()一个子进程，调用exec()运行该命令
    * 不存在就，报告不存在该命令
  * ls程序会分析后面的参数，打印相关信息，返回退出码
  * shell得到退出码，继续等待用户输入
* 常用的Linux命令
  * cd
  * ls
  * grep 
  * find
  * cp
  * rm
  * ps
  * kill
  * file
  * tar
    * tar -jcv - f filename
    * tar -jtv -f filename
    * tar -jxv -f filename
  * cat
    * `$ cat /proc/PID/maps `查看进程的内存空间分布	（内核部分的映射不可见）
  * chgrp
  * chown
  * chmod
  * vim
  * gcc
  * time


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>