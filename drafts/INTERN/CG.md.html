# CG Memo

### 3D Rotation

Rotating $\mathbf{v}$ around $\mathbf{u}$ by $\mathbf{\theta}$ 
$$
\mathbf{v'=cos({\theta})v+(1-cons(\theta))(u\cdot v)u+sin(\theta)(u\times v)}
$$

### Quaternion

$$
q=[a,\mathbf{v}]
$$

##### Imaginary Number
$$
q=a+bi+cj+dk
$$

* $a=\cos(\frac{1}{2}\theta),\ \ b=\sin(\frac{1}{2}\theta)u_x, \ c=\sin(\frac{1}{2}\theta)u_y, \ \ d=\sin(\frac{1}{2}\theta)u_z$

##### Matrix 4x4

$q_1=a+bi+cj+dj,q_2=e+fi+gj+hk$

* **Left Multi** 
    $$
    q_1q_2=
    \left[ \begin{array}{cc}
    a&-b&-c&-d \\
    b&a&\textcolor{red}{-d}&\textcolor{red}{c}\\
    c&\textcolor{red}{d}&a&\textcolor{red}{-b}\\
    d&\textcolor{red}{-c}&\textcolor{red}{b}&a
    \end{array} \right]
    \left[ \begin{array}{cc}
    e\\ f\\ g \\ h
    \end{array} \right]
    $$

* **Right Multi**
    $$
    q_2q_1=
    \left[ \begin{array}{cc}
    a&-b&-c&-d \\
    b&a&\textcolor{red}{d}&\textcolor{red}{-c}\\
    c&\textcolor{red}{-d}&a&\textcolor{red}{b}\\
    d&\textcolor{red}{c}&\textcolor{red}{-b}&a
    \end{array} \right]
    \left[ \begin{array}{cc}
    e\\ f\\ g \\ h
    \end{array} \right]
    $$

**Grabmann Product** 

$ q_1=[s,\mathbf{v}], q_2=[t,\mathbf{u}]$
$$
q_1q_2=[st-\mathbf{v\cdot u},s\mathbf{u}+t\mathbf{v}+\mathbf{v \times u}]
$$
**Conjugate**
$$
qq^*=\|q\|^2 \ \ \ \  \Rightarrow \ \ \ \ q^{-1} = \frac{1}{\|q \|^2}q^*, \ \ \ \ \ \ \ \ (q^*=[s,-\mathbf{v}])
$$
**3D Rotation**
$$
\mathbf{v'} = q\mathbf{v}q^*=q\mathbf{v}q^{-1}, \ \ \ \ \ \ \ q=[\cos(\frac{1}{2}\theta),\sin(\frac{1}{2}\theta)\mathbf{u}]
$$

>  $v'=qvq^*=qq*v_{\|}+qqv_{\bot}=v_{\|}+q^2v_{\bot}$
>
>  **3D Rotation Matrix:(LL, RR)**  v' $qvq^*=L(q)R(q^*)v = Quat(q)_{4 \times 4}v$
>
>  **3D Rotation Matrix:(LR, RL)**  v' $q^*vq=L(q^*)R(q)v = Quat(q*)_{4 \times 4}v$
>
>  (LL is left-hand coordinate with left-hand rule, and so on)
>
>  Det(Matrix) < 0  of Reflection will change the chirality of the coordinate system.
>
>  Likely, Det(Matrix) > 0  of Rotation will not change that.

**Double Cover**

$q$(around $\mathbf{v}$ by $\theta$)  is equivalent to $-q$(around $\mathbf{-v}$ by $2\pi-\theta$), which will be a problem when we lerp between q and -q (Inverse one of the quaternions when cos(q0, q1)) < 0  before lerp.

**Lerp**
$$
\mathbf{Lerp(T, S, F) = \alpha(T)*S + \beta(T)*F}
$$

| Lerp(T, S, F) | $\mathbf{\alpha(T)*S + \beta(T)*F}$ |  |
| ------------- | ----------------------------------- | ---- |
|  Lerp($t,q_0, q_1$)       | $q_t=(1-t)q_0 + tq_1$ | Not identity quaternion |
|  Nlerp($t,q_0, q_1$)            | Normalized(Lerp$(t,q_0, q_1)$) | Not  uniform from t=0 to t=1 (works well when smaller $\theta$) |
|    Slerp($t,q_0, q_1$)           | $\frac{\sin{(1-t)\theta}}{\sin\theta}q_0+\frac{\sin{t\theta}}{\sin\theta}q_1$ | High overhead (be cautious when smaller $\theta$ since divide zero) |
| Squad (Spherical and quadrangle) | Method 1: SBézier(𝑞0, 𝑞1, 𝑞2, 𝑞3; 𝑡) = 𝑆(𝑆(𝑆(𝑞0, 𝑞1; 𝑡), 𝑆(𝑞1, 𝑞2; 𝑡); 𝑡), 𝑆(𝑆(𝑞1, 𝑞2; 𝑡), 𝑆(𝑞2, 𝑞3; 𝑡); 𝑡); 𝑡)    Method 2: Squad(𝑞0, 𝑞1, 𝑞2, 𝑞3; 𝑡) = Slerp(Slerp(𝑞0, 𝑞3; 𝑡), Slerp(𝑞1, 𝑞2; 𝑡); 2𝑡(1 − 𝑡)). | Solved angular velocity at the breakpoint is discontinuous |

### Physics Library

#### 2D: Box2D, Chipmunk

##### 3D: PhysX, Bullet

欧拉计算方法? -> 取前几部分的泰勒展开

* 重心 （barycenter）
* 转动惯量(rotational inertia)
  * 平行轴定理 ：$I_B=I_A+md^2$
  * 垂直轴定理：$I_3=I_1+I_2$
  * 伸展定理：$I_{沿轴向移动质点}=I_0$
  * 组合刚体的转动惯量 =$\sum$ 单个刚体过质心的转动惯量（利用平行轴定理）

* 角动量：$L=I\omega$ ，这里的转动惯量$I$类比平动中的惯量(质量)$m$

* 力矩 类比平动中的力$f$

  * $\tau=r\times f=m*(r\times a)$
  * $\tau=I\alpha$, $\alpha=I^{-1}$是角加速度，类比$F=ma$

  

### Collision

为了避免两两检测是否碰撞，分为Broad-Phase Narrow-Phase

* Broad Phase用Bounding Volume表示刚体碰撞信息，通过空间划分的方式
* Narrow Phase是真正的检测

###### Bounding-Box的类型

* AABB：简单 高性能 保存6个参数，检测每个轴上是否都重叠
* Oriented BB 
* Bounding Sphere

###### 空间划分的方法

* Sweep and prune (删除)：初始化排好序，然后插排更新（因为相对位置一般不变。 或者舍弃一个轴上的检测，比如地上的大量物体舍弃Up轴

* （Hierarchical ）Uniform Grid：处于相同网格的两个物体进行检测，格子大小应与碰撞体大小接近

* Bounding Volume Hierarchical(BVH) **递归式分组**![img](https://pic1.zhimg.com/v2-1d1ab217881abd99d23c611a90e9cb14_b.jpg)

  * BVH不仅用于碰撞检测还有 射线求交、视锥裁剪、裁剪遮挡、光线追踪

  * 构造方法

    * top-down 所有的BV放在一棵树上，适合离线渲染。子节点分割方法可以是所有BV的平均中心作为分割点

    * bottom-up 自下往上构建BVH，效果较好，耗时更长

    * incremental tree-insertion 从空树开始，利用AVL之类的平衡思想

      ![img](https://pic1.zhimg.com/v2-f8abdca3c1022a8371dc5876999d41f0_b.jpg)

    * Linear BVH

    * ![img](https://pic1.zhimg.com/v2-b4811b17a94804fd2feef86362736d54_b.jpg)

  * Binary Space Partitioning(BSP) Tree (K-D Tree)**递归式划分空间**

    * **AA BSP**![img](https://pic3.zhimg.com/v2-4efa7eb2615c8a83bff5d4def71c2ab6_b.jpg)
    * **Polygon-Aligned BSP Trees**![img](https://pic1.zhimg.com/v2-dd922e79fca8d4b32fab7f149b19481c_b.jpg)
    * Octree/Quadtree![img](https
    * ://pic4.zhimg.com/v2-e1b21058527532c6d8c2218f2d7e145f_b.jpg)
    * Loose Octree![img](https://pic1.zhimg.com/v2-032f0ef670627228a9ae6f03cb5992a4_b.jpg)

###### Narrow Collision

凹多边形->生成一个凸的(QuickHull)/分解为多个凸的(V-HACD)

**Separating Axis Theorem(SAT)算法**

两个不相交凸多边形必然存在一直线上的投影不相交，计算另一多边形的所有顶点均在每个边/面之外（利用法线）

弹性碰撞(完全弹性时有$C_r=1$)无能量损耗下：动量守恒+动能守恒->碰撞后的速度 （质量相同则速度交换）

恢复系数 $C_r=\frac{v_{a0}-v_{b0}}{v_{a1}-v_{b1}}$, 





### Mass-Spring

**顶点连接类型**

* structural
* shear
* flexion

**顶点受到的力**

* Spring $F_{spring}=K(L_0-\|p-q\|)\frac{p-q}{\|p-q\|}$
* Gravity $F_{gravity}=mg$
* Damping $F_{damping}=-c_dv$
* Viscous fluid $F_{viscous}=c_v[n\cdot (v_{fluid}-v)]n$

**流程**

* 初始化顶点的质量、位置、固定左上右上角两个顶点
* 基于$x_{i,j},v_{i,j}$计算$F_{i,j}$
* $v_{i,j}=v_{i,j}+\Delta t \frac{F_{i,j}}{m}$
* $x_{i,j}=x_{i,j}+\Delta v_{i,j}$ (为了数值稳定用刚得到的$v_{i,j}$)

**缺点**

* 很难对参数调优
* 不能直接捕捉体积效应，如体积守恒或防止体积反转
* 物体结果取决于弹簧的初始设置

### Position-Based Dynamics (PBD)

**应用**

可应用的物理现象：stretching, shear bending of deformable bodies， pressure and viscosity of fluids, to mention just a few.

头发、布料、可变性/柔软物体、刚体系统、流体

###### **传统方法**

给定力，速度、位置能够通过对加速度的数值积分来得到

追求真实、准确，不考虑速度和可控性

* Finite Element Method (FEM)
* Finite Differences Method
* Finite Volume Method
* Boundary element method
*  Particle-based approaches

**欧拉方法**

基于泰勒展开的折线逼近曲线，将连续变量的微分方程改为离散变量的差分方程的一种方法

* 显示欧拉方法 $y_{n+1}=y_n+\Delta t f(x_n, y_n)$

  * 稳定性差，需要较小的步长，但保持能量

* 隐式欧拉方法 $y_{n+1}=y_n+\Delta t f(x_{n+1},y_{n+1})$

  * 稳定性好，可以用更大的步长，但能量耗散

* 半隐式 $y_{n+1}=y_n+\Delta t f(x_{n+1},y_{n})$

* symplectic 欧拉法 $v_i(t_0+\Delta t)=v_i(t_0)+\Delta t\frac{1}{m_i}f(t_0)$

  $x_i(t_0+\Delta t)=x_i(t_0)+\Delta tv_i(t_0+\Delta t)$

**Verlet 方法**

* 考虑的当前、上一时刻、下一时刻，采用的更高阶的近似（四阶），性能和欧拉差不多
* $x(t+\Delta t),x(t-\Delta t)$分别泰勒展开，
* 两式相加得到 $x(t+\Delta t)=2x(t)-x(t-\Delta t)+a(t)+O(\Delta t^4)$ ，下一时刻位置需要上一时刻位置和当前时刻位置，当前加速度即可
* 两式相减得到 $v(t)= \frac{x(t+\Delta t)-x(t-\Delta t)}{2\Delta t}+O(\Delta t^3)$，当前时刻速度需要上一时刻位置、下一时刻位置

###### 基于位置方法 simplicity, robustness and speed

基于准静态问题忽略加速度、速度直接计算位置，所以很快、很稳定、可控性高，适合交互性环境。物理学意义上的准确不高，但视觉效果好，主要应用于VR, Computer game 



可避免Overshooting 和 penetrations

**牛顿迭代法**

（五次及以上多项式无根式解）不断作切线，接近于根

可收敛的充分条件：$f$二阶可导，根的周围就会存在一个区域，对此区域内的点应用牛顿迭代法可收敛至根

只能求附近 的根，而不是所有根

* 

### **算法介绍**

**Time Integration**

* Initialize $x, v, w=m^{-1}$
* Loop:
  * for all vertices $v_i \leftarrow v_i + \Delta t w_i f_{ext}(x_i)$
  * for all vertices  $p_i \leftarrow x_i + \Delta tv_i$ （$p_i$ only used as predictions）
  * for all vertices $genCollConstraints(x_i \rightarrow p_i)$
  * Loop:
    * $projectConstraints(C_1,...,C_{M+M_{COll}},p_1,...,p_2)$
  * for all vertices $v_i \leftarrow (p_i - x_i)/\Delta t, x_i \leftarrow p_i$
  * $velocityUpdate(v_1,...,v_N)$







# Position-Based Dynamics (PBD)

### 简介

传统的动力学模拟方法是基于牛顿第二定律的力学模拟，对时间积分得速度(velocity)、位置(position)



基于位置的动力学模拟，即PBD，忽略了加速度层(acceleration)和速度层(velocity layer)直接工作在位置层(position layer),主要的优点是强大的可控性。可以灵活地把顶点位置投影到有效位置来解决Overshooting，Collision，Penetration难题



#### 阻尼(damping)

#### 解算器(solver)

顶点的位置矩阵：$x=[x^T_1,...,x^T_N]^T$

需要满足$M个约束$ $C_j(x)\succ 0 \ \ \ \ (\succ$ denotes $ = or \geq)$

* 线性化 $C(x+\Delta x)=C(x)+\nabla C(x) \cdot \Delta x + O(|\Delta x|^2)=0$ 也就是 $\nabla C(x) \cdot  \Delta x=-C(x)$
* 通过把$\Delta x$限制在 $\nabla C$的方向上，得到 $\Delta x = \lambda M^{-1}\Delta C(x)$ 这里$M=diag(m_1,m_2,...,m_N)$
* 对每个粒子$i$而言就是 $\Delta x_i=-\lambda w_i \nabla x_i c(x)$，这里$\lambda=\frac{C(x)}{\sum_j w_j |\nabla x_jC(x|^2}=\frac{C(x)}{\nabla C(X)^TM^{-1}\nabla C(X)}$
* 每个约束的线性化的独立的，顶点的位置在每个约束下立即更新，并应用于下一个约束。但这种非对称性不会产生错误，因为每个约束都会产生一个关于拉格朗日乘子$\lambda$的标量等式

**Hierarchical Solver**

对mesh进行分层(粗网格、细网格)，加快错误传播，加快收敛速度

**Stiffness**

因为多次solver iterations会导致$k$的误差累积，需要$\Delta x(1-k')^{n_s}=\Delta(1-k)$用$k'$代替$k$来计算，达到$k$的效果

**Collision**

* 求顶点在三角形平面的法线分量，来模拟布料的厚度（self-collision)
* 求顶点的凸多边形面的法线分量，来模拟布料顶点与几何体的碰撞
* 求两个顶点之间的距离是否大于半径和，来模拟顶点之间的碰撞

**Volume Conservation**

* 四面体体积保持约束 $C(x_1,x_2,x_3,x_4)=\frac{1}{6}(x_{2，1}\times x_{3,1}) \cdot x_{4,1}-V_0$
* 三角形面积保持约束 $C(x_1,x_2,x_3)=\frac{1}{2}|x_{2，1}\times x_{3,1}|-A_0$

## Game Memory

* 不同的CPU架构设计多元&复杂

* 不同层级的存储结构访存速度差距巨大（10^3)

* 提高算法？提高访存效率√

    

    ### 内存分配器类型  

* **malloc-free**

    * 支持任意尺寸内存分配
    * 考虑到内存回收合并free开销远大于malloc （DLMalloc)
    * 绝大部分实现依赖于Global Mutex (JeMalloc)
    * 容易造成内存碎片

* **Linear Allocator**

    * 申请，指针线性增长
    * 释放，DO NOTHING
    * 特点时间重置
    * 应用场景
        * 每帧生成的渲染状态数据 （每帧开始前重置Pointer为0)
        * 每帧送给GPU的骨骼动画数据
        * 比如更新一个很大的node的transfrom(这种帧访问频率很高的property)，下面很多node，那么线性分配，这些Objects在内存的分布上就是趋于连续的，CPU会帮忙prefetch，就能提高常数倍的速度
    * 优点
        * 容易支持LockFree (Intel xxx)
        * 效率高，仅需要index递增操作

* **Stack Allocator**

    * LinearAllocator 基础上实现
    * LIFO by marked positions
    * 应用场景
        * 关卡资源加载（基础关卡放在栈底，第一关压栈、第二关压栈....)
    * 优点
        * 性能类似Linear Allocator
        * 可按需进行释放
        * 可作为其他allocator的back allocator

* **FreeList Allocator**

    * 用链表形式管理的连续内存
    * 申请、释放复杂度为常数
    * 应用场景
        * 粒子特效缓冲池
    * 缺点
        * 连续申请返回的内存不连续
        * 通常是固定尺寸

* **Buddy Allocator （类似OS中的**

    * 支持2^n大小的内存
    * 自动合并相邻内存
    * 应用场景
        * 可能会持续多帧
        * 某些容易是2^n大小的文件，如贴图
        * GPU上的内存管理

* **Handle Based Allocator**

    * 申请后不直接返回 VOID*，返回一个代表这个对象的handle(U32,U64)
    * 生存期的复杂对象，不存储指针，使用handle访问，确保没有野指针访问
    * 应用场景
        * Win Object handle
        * 主线程和渲染线程的指针访问冲突，各自访问线程的实例之后在进行buffer交换
    * 优点
        * 可以被随便拷贝
        * 杜绝上层访问错误
        * 降低耦合

### 面向数据的设计方法

entity conponent system

### 多线程

根据帧更新频率来划分

双BUFFER

![image-20210810154904193](C:\Users\carnotli\AppData\Roaming\Typora\typora-user-images\image-20210810154904193.png)

**渲染线程分离**

* UE系 基于RenderCommand的RingBuffer (会有producer-consumer问题)
* Halo系 基于GameState的DoubleBuffer （双BUFFER,，每帧结束时交换指针，相当于同步地复制了一份内存，内存开销很大，GameState的拆分（逻辑状态 vs 图形渲染状态）也会很困难

两个库： MS ConRT  Intel TBB



### 主流物理引擎

* **PhysX** by NVIDIA
* **Havok** (收费)
* Bullet (性能问题，不咋使用)

固定时间片

SIMLATE() 和 FETCHRESULT() 必须成对调用，后者是线程同步点
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>