## 基本概念

### 引用和指针

指针有自己的一块空间，而引用只是一个别名（使用``++``运算符的意义不一样，`sizeof`不一样），实际上是常量指针 `const int *ref = &x;`

悬空指针就是指向一个已删除的对象即内存已经被释放的指针

野指针就是未初始化的指针，也就是申请访问受限内存区域的指针

### 智能指针

智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。

智能指针是把普通指针封装为一个对象，在对象生命周期结束时，其管理的内存也会被考虑是否释放。作用就是管理一个指针，可以处理忘记释放、多次释放内存的情况

#### auto_ptr（被11抛弃）

#### shared_ptr

多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。

* 对象读取需要加锁
* 不同于`unique_ptr`，无法直接管理数组，不妨使用容器代替
* 拷贝构造、赋值运算均采用复制语义。`std::move` 仍然可以被用于实现所有权转移。
* 不要用同一个原始指针初始化多个`shared_ptr`，否则会多次释放内存
* 避免循环引用
* <img src="https://raw.githubusercontent.com/NoSW/CloudImg/main/img/202205281230806.png" alt="image-20210317150114953" style="zoom:50%;" />

#### weak_ptr

观测`shared_ptr`的引用计数，不会改变计数。通过使用lock()返回一个可用的`shared_ptr`，若资源已经释放，则创建失败。

#### unique_ptr

```c++
auto up = std::make_unique<T[]>();
```

保证同一时间内只有一个unique_ptr可以指向该对象，即资源只能同时被一个实例拥有

* 当它指向其他对象时，之前所指向的对象会被摧毁
* 当 `unique_ptr` 超出作用域时，指向的对象也会被自动摧毁
* 拒绝复制语义但允许移动语义
* 类似的想法去构建一棵树。父节点持有子节点们的 `shared_ptr`，而子节点持有父节点的 `weak_ptr`。此时，若释放父节点，则它子树内的所有节点应当都被释放。

### lambda表达式

```c++
[capture list] (params list) mutable exception-> return type { function body }
```

---

### 异常

### 操作符重载



### 名称空间



### 关键字

* static
* const
* explicit
  * 声明为explicit的构造函数不能在隐式转换中使用，如赋值运算符无法使用。
  * 只能用来修饰类构造函数
  * 只用于单参构造函数，因为无参和多参也不会发生隐式转换。
  * 禁止类对象之间的隐式转换
* inline
* virtual
* volatile woletail
  * 提供对特殊地址的稳定访问
* auto
* cast
  * C的强制转换转化不够明确，不能进行错误检查，容易出错

    * const_cast
      * 对const变量进行操作，移除变量的常量性
      *  用于将const变量转为非const
    * reinterpret_cast
      * 1对二进制数据重新解释，不改变格式
      * 而static_cast会改变格式进行解释
    * dynamic_cast  向下安全转型
      * 将指向派生类的基类指针转换为 指向派生类 或指向兄弟类。 而static_cast只能指向派生类
      * 向上（子->父）时与static相同；向下会冬天检查，耗时高
    * static_cast
      * 主要用于数据类型转换
      * 编译时检查，没有运行时检查保证安全性
      * 用于非多态的转换
      * 向上转（子类->父类）是安全的；向下，没有动态检查是不安全的
      * 把任何类型的表达式转为 void类型
      * 不能转换掉const  volatile ,__unaligned属性
* new
* 关键字
  * 从自由存储区（可以说堆上，也可以是静态存储区）上
  * 自动推断需要的大小
* malloc()
  * 库函数
  * 从堆上动态分配内存
  * 指出大小



### 函数重载(overload)

* 函数名相同，返回值无关紧要，参数列表不同（个数，类型、顺序）
* 相同的范围
* 重载顺序。。。

函数重写（override）

* 不同的范围（不同的类
* 函数名相同，参数相同
* 基类必须有virtual
* 发生条件
  * 基类中用了virtual，且派生类中的参数列表和基类中的相同

函数覆盖/隐藏（overwirte）

* 派生类的函数覆盖掉了基类中的同名函数，使其在该派生类中不可见
* 发生条件
  * 基类中没用virtual
  * 基类中用了virtual, 但派生类中的参数列表和基类中的不同。

## STL

### 容器

* array：定长数组
* vector：动态数组
  * 插入 $O(n)$
  * 删除$O(n)$
  * `push_back()` $O(1)$
  * 随机访问 $O(1)$
  * 自动扩容，每次扩容至原容量的两倍，比较浪费空间
* deque：双端队列
  * 随机访问性能不如vector
  * 内部随机插入删除不如list
  * 适合头部和尾部的插入删除。
* priority_queue
  * 优先级高的先出队
  * 底层是堆
* list：双链表
  * 不支持[] 和.at()
* string
* map
  * 红黑树
  * 键不可重复
* unordered_map
* set
  * 内部是RB树
  * 快速查找，不允许重复值
* multiset、multimap
* unordered_map
  * 散列表
  * 占用内存较大一点
  * 适合频繁查询

### 迭代器



## 程序编译原理

对于C++源文件，从文本到可执行文件一般需要四个过程：

预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。

编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件

汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件

链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件



不可虚：非成员、构造、静态、友元（无继承特性）、内联（编译阶段）



左值使用(操作)的是绑定的内存地址  右值（一般是`&&`）使用的是内存地址的值

所以`const int &x = 42` √

**接受和使用右值引用的代码，可以自由地接管所引用的对象的资源，而无需担心对其他代码逻辑造成数据破坏**。



大数据量的排序问题

c++的 RAII(resource acquisition is initialization)



c++优异于C#/Java的原因：

* 直接以静态形式把源程序编译为目标平台的机器码
* 编译及连接时可进行的优化最丰富，运行时额外内存开销小
* 没有Python/Lua的运行时动态类型检查
* 没有GC的不确定延迟
* 数据结构在内存中的布局是确定的
* 直接映射机器码，没有中间层语言，可以做底层优化，如嵌入汇编码
* 跨平台能力较弱





* NULL在c++中编译为 0，但可能引发函数重载的错误(误指针类型当作整型)
* nullptr 本身是有类型的，重载时不会发生上述问题



* **可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用**`std::move`**触发移动语义，提升性能。**



* 判断大小端的方法
* 为什么大小端？计算机电路先处理低位字节，效率比较高，计算也会比较快，因为计算都是从低位开始的。所以，**计算机的内部处理都是小端字节序。在计算机内部，小端序被广泛应用于现代 CPU 内部存储数据；而在其他场景，比如网络传输和文件存储则使用大端序**。另外大端方便阅读，可快速判断符号正负



* `=delete `函数禁用（c++11）



* 虚函数开销：cache不友好，没法inline，通过虚函数指针间接跳转；动态代码影响指令pipeline的流畅





* |                                                              |                                                              |                                                              |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | `emplace_back(T&& _Val)`                                     | 直接调传入参数的构造函数                                     |                                                              |
  | `push_back(const T& _Val)`                                   | 直接掉传入lValue（不接收rValue）的拷贝构造函数，如果在`()`里构造了个类i，相当于调了一次构造+一次拷贝构造 |                                                              |
  | `push_back(T&& _Val)`                                        | 与楼上的区别是用来接收rValue但不接收lValue，因为`T&`不接收rValue，`const T&`可以 |                                                              |
  | `T&& forward(T&& param)`                                     | 实现完美转发，保留参数的左/右值特性，参数是lValue->直接返回;否则返回move(param) | 在模板函数中中，左值也可以传给T&&，通过`std::forward`得到该值的原本的左右值特性 |
  | `std::move()`                                                | 把一个值转为rValue，用来配合移动构造函数使用，原有的obj置于moved state，避免拷贝开销 |                                                              |
  | `std::transform(first1, last1, out_begin, unary_func)`       |                                                              |                                                              |
  | `std::transform(first1, last1, first2, out_begin, binary_func)` |                                                              |                                                              |

in some regard 在某些方面



* `typename `在类内嵌套的情况下可以告诉编译器后面跟的表示类型，而`class`无此作用





* iterator可隐藏不同容器的实现细节，实现统一接口，数据结构（容器）与算法分离



## c++并发的常用操作

<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>