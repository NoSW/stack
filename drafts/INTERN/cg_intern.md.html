* **MVP Transform**
  * model transform
    * rotation matrix
    * scale matrix
    * translate matrix
  * view transform
    * 把camera transform到原点，up at +y,  look at -z
  * projection transform
    * ortho matrix
    * persp matix

* **Rasterization**
  * 判断点是否在三角形内，多边形内(射线交点奇偶法）
  * 低/高通滤波器
  * pre-filter抗锯齿
  * supersampling抗锯齿 （MSAA）
  * 更多抗锯齿：FXAA(图像后处理)， TAA(复用时间帧)，DLSS（深度学习）

* **Shading**
  * blinn-phong reflection model  $L=k_aI_a+k_d(I/r^2)max(0, n \cdot l)+k_s(I/r^2)max(0,n\cdot h)^p \ \ \ \ h =\frac{in+out}{\Vert in+out \Vert}$
  * shading frequencies
    * each triangle , flat shading
    * each vertex, gouraud shading
    * each pixel, Phong shading 
  * 求顶点法线
  * z-buffer伪代码
  * graphics pipeline
    * vertex processing (模型和摄像机的transform)
    * triangle processing ()
    * rasterization （采样，将像素采样到二维平面）
    * fragment processing （z-buffer深度测试）
    * shading （blinn-phong模型 + texture mapping）

* **Texture**

  * barycentric coordinates，可用来在三角形内插值，set diffuse color

    ```
    for each rasterized screen sample(X, y):
    	(u,v) = evluate texture coordinate at (x, y) # using barycentric coordinates
     	texcolor = texture.sample(u,v)
    	set sample's color to texcolor # (k_d in blinn-phong model)
    ```

  * too small? Bilinear Interp or Bicubic Interp

  * too big? Mipmap

    * $D=log_2L$, $L$ is maximum distance between two adjacent pixels
    * Trilinear = Interp between Bilinear Interp of level  $D$  and level  $D+1$
    * 容易产生Overblur难题，解决:各向异性过滤、EWA过滤

  * (spherical) environment map

  * environment lighting

  * cube map

  * bump mapping

  * displacement mapping

* **Geometry**
  * implicit surface
  * explicit surface
  * distance functions?
  * level set?
  * fractals?
  * mesh的存储形式
  * Bezier curves
  * mesh subdivision
    * Loop subdivision (only triangle)
      * 新顶点更新方式？
      * 旧顶点更新方式？
    * Catmull-Clark subdivision (general mesh)
      * 对每个三角形面内添加一个顶点
      * 对每条边的中点添加顶点
      * 连接新的顶点
      * 更新方式？
  * mesh simplification
    * 捏合一条边
    * 二次误差度量（使得新顶点到原来旧顶点的平方距离和最小）
  * mesh regularization
  * shadow mapping
    * 从光源角度记录深度
    * 从观测者角度记录光源距离该点的深度
    * 是否深度一致
    * 难题
      * 硬阴影
      * 依赖于resolution
      * 浮点相等比较误差

* **Ray tracing**

  * whitted-style 递归式光线追踪

  * ray casting 射线检测

    * 光线表示
    * 光线与隐式求交点
    * 光线与三角形求交点（三角形内的点表示为重心坐标形式，解线性方程组）

  * 空间管理

    * 射线与AABB求交 $t_{enter} < t_{exit}\ \ AND \ \ t_{exit}>=0，\ \ \ t_{enter} = max\{t_{min}\},t_{exit}=min\{t_{max}\} $
    * 非轴对齐 $t=\frac{(p'-o)\cdot N}{d\cdot N}$，计算量偏大
    * 均匀网格
    * 空间划分
      * Oct-Tree（均等分）、KD-Tree（二分，轴轮换，冗余点，三角形求交计算困难）、BSP-Tree（非轴对齐）
      * BVH
        * 找到一个BB
        * 划分为两个部分（找中位数？）
        * 重新计算BB
        * 在需要时停下

  * 辐射度量学

    * $Q$

    * Radiant flux $\Phi=\frac{dQ}{dt}$

    * Intensity $I(\omega)=\frac{d\Phi}{d\omega}, \ \ \ \ d\omega=sin\theta d\theta d\phi$

    * Irradiance $E(x)=\frac{d\Phi(X)}{dA}$

    * Radiance $L(p,\omega)=\frac{d^2\Phi(p,\omega)}{d\omega\ dAcos\theta}=\frac{dE(p)}{d\omega \ cos\theta} = \frac{dI(p,\omega)}{dA\ costheta}$

    * BRDF  $f_r(\omega_i \rightarrow \omega_r)\frac{dL_r(\omega_r)}{dE_i(\omega_i)}$

    * rendering equation

    * monte carlo求定积分

    * path tracing 伪代码

      ``` 
      shade(p, wo):
      	# from light source
      	Unifromly sample the light at x' (pdf_light = 1/A)
      	shoot a ray from p to x'
      	If the ray is not blocked in the middle:
      		L_dir = L_i * f_r * cons(theta) * cons(theta') / |x'-p|^2 / pdf_l= shadeight
      		
      	# from other reflectors
      	L_indir = 0.0
      	Test RR with P_RR
      	Uniformly sample the hemisphere toward wi (pdf_hemi = 1/2Pi)
      	Trace a ray r(p, wi)
      	If r hit a non-emitting object(Non-light) at q:
      		L_indir = shade(q, -wi) * fr * cons(theta) / pdf_hemi /P_RR
      		
      	Return L_dir + L_indir
      ```

* **Material**

  * $f_r=\frac{\rho}{\pi}$推导（假设入射反射均匀，不吸收）

  * 反射立体角推导（用入射立体角、法线表示）

  * 折射定律

  * fresnel term

  * microfacet 方程

  * 各向同性、各向异性BRDF

  * BRDF性质

    * 恒大于0

    * 线性可加

    * 可逆性

    * 能量守恒 

      

里面的解算器。他对顶点集位置更新时，需要考虑两个维度的问题。一个是顺序逐顶点更新，保证后续更新的顶点不会影响已经更新好的顶点，另一个是每个顶点都要满足多条约束(已基本的距离约束等，如果开了自碰撞和布料间碰撞还要考虑这些) 对某个顶点约束结算时，能保证不同约束同时满足。这儿考虑应该用一个全局的解算方法。但一般约束都是非线性，比如自碰撞。所以线性方程组那一套解法就没办法用。但我们可以泰勒展开，取一阶近似做到这一点。论文中就是这么做的。但比较迷惑的是，在得到一组关于顶点位置的线性约束后，他也没用全局约束，而且逐约束更新？


主要是参考ue的源码。但ue接口源码有很多对ue模块的设计代码。比如和编辑器相关的部分，此外还有一些legacy的代码段，因为NvCloth出来前，ue用的是apex。用了nv后，他考虑兼容的问题，之前的接口代码没有说完全删掉。而且我们还要解决这边引擎的带来的特定问题。比如角色模型中，一块视觉上整体的裙子，他底层是由3－4块节点组成。也就是会存在某些顶点对应的索引值不唯一，有的顶点存存储了多次。那么处理的方法是在布料初始化阶段。为这个碎布建立一个索引映射机制。来保证在逐帧更新时，直接通过映射表解决索引不唯一的问题。这样做因为是在初始化阶段建立的索引映射。所以不会有任何额外的性能的上的开销，但是额外增加了每个布料数据结构所占据的内存，你用unsigned shor存索引值，1000个顶点，大约得4MB。但这么做，只需要初始化多两个函数，逐帧更新时改一两行代码就行，速度也没有变糟。但其中还有一个设计方面的trade1off考量，也就是设计一个通用接口可以处理多块碎布，和整布。还是两者分开处理。因为整布没有上述问题，是直接逐帧更新的，这样可以省去初始化阶段的映射建立，更重要的是可以减小内存开销，但代码量会变大，要额外的逻辑分开处理。但正常情况是没有碎步的问题的。视觉上整块的布料，底层存储必是连续的。这只是引擎原生模型的问题。因为模型资源都是几年前做的了。而且目前阶段也还没考虑要不要让美工对模型做出修改。尽量程序这边解决掉问题。


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>