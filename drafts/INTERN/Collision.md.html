# Collision

borad: **SAP**, **BVH**, **AABB**

narrow: **SAT**（计算在每条边的中垂线上的投影，如果每条边均重叠则相交，最短重叠向量，即为分离向量）, **GJK**(任选多边形A指向多边形B的向量，计算投影点的闵可夫斯基差，得到两个点，再计算一遍垂直向量得到两个点，构成三角形/单纯形，若不包含原点，则选择靠近原点的边的垂线方向作为新的搜索向量重复操作，直至新的到点与搜索方向的夹角为钝角。)+**EPA**（拓展单纯性，将距离原点最近的边的垂线的背离原点方向作为拓展向量，得到新的单纯形顶点，直到不能得到新的顶点，此时拓展向量即为分离向量）



#### NvCloth Sphere acceleration structure

SAP(sweep and prune) 来避免每个粒子和每个sphere检测碰撞

首先是把空间均与划分为为一个8x8x8的grid，里面包含了所有的虽有的particles和spheres。3个主轴，每个轴有8个bitmasks，每个bitsmask上的bit位对应一个sphere。例如，gird的划分间隔假设是1，也就是把布料局部空间化成的8x8x8个单位立方体。我们只有一个置于原点的单位球，那么所有bitmask的长度就是1bit，那么x轴上有8个Bitmasks，那么中间索引，也就是索引为3 4 的bitsmask的索引为0 的位置值为1.y,z轴同理。

> ​	如果问到bit操作。csapp的mod3和int<->float运算lab，以及RSA的项目实战可以吹。有些情况下bit位的并行操作可以避免race condition，高级语言编程c++倒是还没咋见过这种情况。



在此基础上把所有的bitmask比特数组存储两个备份，用于CCD。做法是，第一个备份是拓展至右侧，第二个拓展至左侧。拓展至右侧的意思的，比如单位体积球沿x轴的占据索引是3 4 那么 索引为5 6 7bitmask 也被标记。左侧就是 0 1 2 也被标记。

所以现在有三组bitmask。thick(sphere是否在里面) , right, left。实际运算时，thick bitmask可以通过 right AND left得到。

如果CCD关闭，就只用thick bitmask就行了。如果开启了CCD，对于待检测粒子的起始位置和终止位置，较大的值用right bitmask检测，较小的值用比left bitmask检测，如过两者有一个的bit位是1就说明在该轴上发生了CCD，三个轴上均CCD就判定发生了CCD，否则就culling掉这个sphere。

其他复杂的多变体同AABB来做bitmask.

#### static collide / dynamic collide

根据碰撞物的物理表现，分位sc和dc。sc之间互不检测。

#### cone collision detection

两个spehe，球心坐标不一样，半径大小也不一样，组成一个锥形的的碰撞体，用一个二元球体索引组来访问，类似三角形用一个三元顶点索引组。

求解的方法是。先求出锥体的主轴，也就是两球心的连线，然后在主轴上插值出来一个球S(k)，k的范围是[c1, c2]，计算待测点和S(K)相交时k的值，看看是否在合理范围内。

#### sphere CCD

粒子和spere都进行线性运动。

根据粒子的起始位置和终止位置，得到粒子关于t的p(t)

根据球心的起始位置和终止位置，得到球心关于t的c(t)

然后，计算 |p(t) - c(t)| ^2 <= r^2 ，解t是否在0-1之间。

然后这个t是可以表示为一个关于已知数据的带有根号的复杂分式的，所以计算代价主要是浮点求根号以及浮点除法的开销。

#### self collison

上面是和固定几何体的碰撞。自碰撞是为了防止布料自身穿插，是保持粒子与粒子之间一个固定的距离。把粒子看作一个假想的sphere，这个半径距离作为一个参数，可以手动设置。所以检测很简单，主要是检测开销。两两检测，就是O(V^2)。只检测临近粒子通过如下方式：

做法也比较简单。对布料的AABB再次划分，最长的轴作sweep，剩余俩轴作为256x256的切分（切分的规模是保证且放的立方体比参数半径要大。只和在同一个cell和相邻cell的粒子作检测。

通过粒子三维坐标可以常数时间内转换得到粒子所在的cell的索引坐标，把这个索引坐标组织成key，对所有粒子排序，根据排序的结果快速地进行粒子间的自碰撞检测。

还有第一个和最后一一个cell作为哨兵这种。

#### inter collision

避免多个布料之间碰撞发生穿插。主要是让布料A的每个顶点与布料B的每个顶点保持一个最小距离，这个距离作为一个参数，可以手动设置。检测加速结构主要是两个方面。

* broad 根据布料的AABB盒，判断两个布料之间是否有必要进行inter collision detection
* narrow 就是根据布料A的AABB和布料B的AABB，merge两者得到一个大AABB，在这个大AABB中运用self collision的思路，来做到粒子仅与临近的粒子们进行检测。
* 至于布料之间两两检测的平方开销，就没必要优化了。毕竟一个角色身上也没几块布。简单地通过AABB的broad阶段就足够了


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>