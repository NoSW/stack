### **范式（Norm Forms）**

* 无损分解：即数据等价，分解前后的两个数据库实例表示同样的信息内容。
  * 如果R分解为R1, R2，用两个关系模式r1(R1) 和r2(R2)代替r(R)时没有信息损失，称为无损分解
  * 等同于 如过R1∩R2 是R1或R2的超码，就是R上的无损分解
  * 等同于：把r投影到R1和R2上，然后计算投影的自然连接，仍得到一样的r，叫无损分解
  * **chase**检测：
    1. 选择一张k行n列的表格。每列对应一个属性Aj，每行对应一个关系模式Ri。如果Aj在Ri中，就在i,j处添上符号aj，否则填bij
    2. 把整个表格看作R的一个关系，反复检查F中的每个FD是否成立，若不成立，修改表格，即chase过程
    3. 若修改的最后一张表格有一行是全a，则无损，否则有损
* 保持依赖：即依赖等价。分解前后两个数据库应有相同的依赖集闭包，在这个情况下，数据库的语义是不会出差错的。
  * 如果分解之后得到的F1, F2,... 如果(F1∪F2∪...)+ = F+ ，称保持依赖的。
*  正则覆盖：F的最小依赖集Fc
  * Fc中的任何FD都不含无关属性
  * Fc中任何FD的左半部都是唯一的

因为引入了FD，所以关系中会有数据冗余的问题。使用FD进行分解：

* 1NF：关系模式的每个关系域是原子的，不可分割的最小数据单元
* 2NF：每个非主属性完全函数依赖于候选键
* BCNF：对F+(即函数依赖闭包)中任意的FD: x->y，要么x是超码，要么是一个平凡FD，即（x包含y）
* 3NF：对任意的FD: x->y，要么满足BCNF的约束，要么y-x的每个属性A都包含于R的一个（可能不同的）候选码中
* 和多值依赖有关的4NF、和嵌入多值依赖的5NF



* 减少数据冗余，和数据缺失





一般的数据库设计目标是：

* BCNF
* 无损分解
* 保持依赖

但不是总能同时达到这三个目标，需要在BC

NF（由无损BCNF分解算法得到）和保持依赖的3NF（由无损且保持依赖3NF分解算法得到）中抉择

* 无损BCNF分解：对每个不符合的FD：X->Y分解为Ri-Y和XY两个模式，重复直至为BCNF
* 无损且保持依赖3NF分解：
  * 先求最小依赖集，再把左部相同的FD合并起来
  * 每个FD：X->Y构成一个模式XY
  * 如果每个模式都不包含R的候选键，就把候选键作为一个模式放入模式集



### 平衡树

* B+树：树结构的索引
  
  * 所有的指针记录保存在叶子节点，所有非叶节点至少半满
  
* B树，与B+树的区别在于，B树去除了搜索码值存储的冗余，在非叶节点上也存储指针记录，也就是搜索码值只出现一次。

  * 相比B+树，删除更复杂

* （也有的是实现是B树在叶子和非叶都存储数据，而B+只在非叶存储数据

  

B+树相比于B树，IO更少，且效率更稳定，更适合范围查询

### 索引

* (非)聚簇索引
* 前缀索引：把值的一部分作为索引值
* 覆盖索引：比如在一个建立在ID属性上的非聚集索引把salary与记录指针一起存储
* 静态索引：即基于散列的索引，避免了二分查找和多级索引，减少了IO
  * 桶不足、偏斜问题
* 动态散列：比如一个搜索码表示成二进制数据是32位，$2^{32}$大概是4x10^9次方，一个桶4KB那么总共就是16TB那么大，显然没必要。那么我们就可以选取前几位作为散列值，当发生桶溢出时，就把溢出桶分裂为两个桶。比如原来是的溢出桶编号的000，分裂成0000 和 0001.
* 位图索引，比如性别只有两个值要么0要么1，比如薪资水平，可以划分若干个等级区间。对每个离散的值，建立一个位图。对每个记录进行编号，然后男性的位图、女性的位图；L1的位图，L2的位图等。
* 多级索引
  * 概念
  * 应用场景

需要考虑：

* 索引或散列组织的周期性重组代价
* 插入删除的相对频率
* 最快情况和平均情况的优化权衡
* 数据库用户可能会提出那些类型的查询，哪些比较频繁，哪些需要提升速度
* 总直接就是根据需要优化再优化



**查询处理**

* <img src="https://raw.githubusercontent.com/NoSW/CloudImg/main/img/202205281231473.png" alt="image-20210410172224615" style="zoom:33%;" />
* 优化考虑
  * 直接线性搜索还是索引扫描？
  * 主索引还是辅助索引？
  * 确定采用的索引后，是码等值比较还是非码等值比较？是等值还范围查询？
  * 复杂选择的实现：多属性查询
    * 取交
      * 利用其中一个属性的索引，再判断是否满足其他条件
      * 使用适当的组合索引（建立在多个属性上的索引）
      * 对于每个条件上的索引取其指针记录的交，剩下的某些没有单个属性索引的属性，再进行下一步判断
      * 总之充分利用单属性索引、组合索引，剩下的再做进一步判断
    * 取并
      * 分别在相应的单属性索引上取其指针记录的并。当有一个属性不存在索引时，就需要我们直接进行线性扫描

### 事务

是一个操作序列

四个特性

* Atomic, 原子性：事务所执行的 操作要么全反映出来要么全不反映
* Consistency 一致性：在并发执行的情况下，保证数据库的一致性
* Isolation 隔离性：每个事务感觉不到并发的事务，也就是事务对T1来说，T2要么在T1开始前执行结束，要么在T1完成之后才开始执行。
* Durable 持久性：一个事务成功完成后，他对数据库的改变是永久的，即使出现系统故障。

**读**

* 脏读：A读取了被B修改后但未提交的字符段，然后B回滚了
* 不可重复读：A读取一个字段，B修改该字段后提交，A再次读该字段
* 幻读：A读取某范围记录时，B在该范围插入了新的值，A再次读取该范围的记录，会产生幻行

**隔离级别**

| 事务隔离级别                   |                                                              | 脏读（读取了未提交数据 | 不可重复读（同一事务对同一数据项两次读取期间不一致 | 幻读（涉及全表的操作。如T1对全表进行了修改，同时T2向表中又插入了一条新记录） |
| ------------------------------ | ------------------------------------------------------------ | ---------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 读未提交`（read-uncommitted）` | 允许读取未提交数据，不允许脏写（不允许多个事务对同一数据项的并发写操作） | 是                     | 是                                                 | 是                                                           |
| 读已提交`（read-committed）`   | 只允许读取已提交数据，但不要求可重复读                       | 否                     | 是                                                 | 是                                                           |
| 可重复读`（repeatable-read）`  | 只允许读取已已提交数据，而且在一个事务两次读取同一个数据项期间，其他事务不可更新该数据 | 否                     | 否                                                 | 是                                                           |
| 可串行化`（serializable）`     |                                                              | 否                     | 否                                                 | 否                                                           |

* **实现**
  * 锁
  * 时间戳
    * 系统时间戳 、 逻辑时间戳（每分配一个戳，计数器+1）
    * 每个事务有一个时间戳，每个数据项有一个写时间戳、读时间戳
      * 请求read(Q)，需要TS(T) >= W-TS(Q)才允许，否则回滚
      * 请求write(Q)，如果TS(T)<R-TS(Q)，回滚，否则，如果TS<W-TS(Q)回滚（thomas写规则中是忽略该write操作） 否则才允许write(Q)
    * 无死锁的，因为不存在等待的事务
  * 快照隔离：（通过维护数项的多个版本）每个事务都有一个私有的数据库快照，对数据项的更新体现在快照上，不会受其他事务的影响，也不会影响其他事务，当提交时，如果该快照上有被修改的数据项，那么只有当数据库的该数据项没有修改时才提交成功，否则事务终止。


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>