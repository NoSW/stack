### ·类

* **变量**
  * **类变量**
    * 也就是public static 成员变量
    * 定义在类内，类的成员函数外
  * **实例变量**
    * public 成员变量
    * 定义在类的成员函数内
* **方法**
  * **静态方法**
    * public static
    * 使用`@staticmethod`装饰器修饰
    * 抽象出类内的相关逻辑
  * **类方法**
    * 第一个参数为`cls`（类类型） 静态方法
    * 使用`classmethod`装饰器修饰
    * 处理类对象
  * **实例方法**
    * 第一个参数为`self`（类实例） 的成员函数
    * 处理实例对象
* **Note**
  * python只允许定义一个构造函数，可以利用类方法实现`create()`来模拟多个构造函数

---

### 继承机制

`super`

* **指代父类类型，可维护性高**
* **解决多继承的重复调用问题**
  * 通过`super(class-name, self).func()`，可以避免对祖先类的成员函数的重复调用
* **解决查找查找顺序问题**（MRO, Method Resolution Order）
  * 定义：python为每个类生成一个tuple类型的数据`__mro__`，当用super调用父类方法时，会按照`__mro__`属性中的元素顺序挨个查找方法。一般结构是
  * 一般结构是：`(<clasws '__main__.current-class'>, <class '__main__.father-calss1'>， <class '__main__.father-class2'>, ..., <class ‘__main__'.ancestor-class>, ...)`
  * 采用的算法：c3。对继承树进行拓扑排序，左侧优先(先定义者先放在左侧)
* **使用方法**（三种格式）
  * **`super()`**
    * 只能用在类内部
    * 自动填充为`super(__class__, self)`
  * **`super(type, obj).func()`**
    * 从`obj`的`__mro__`中查找到`type`的下一个父类，调用这个类的`func()`
  * **`super(type_1, type_2)`**
    * `type_2`必须是`type_1`的子类
    * 从`type_2`的`__mro__`中查找到`type_1`的下一个父类，返回这个类的类代理（没有实例，不能直接调用实例函数）
      * `super(A, A).func()`，ERROR
      * `super(A, A).func(A())`，OK
      * 所以，这种情况下最好调用的是静态方法和类方法。
* **Note**
  * super 的第一个参数尽量为当前的类

---

### 装饰器（Decorators）

* **函数**

  * 也是对象
  * 可赋值给其他变量
  * 可作为参数传递给其他函数
  * 可在函数内定义函数
  * 可作为返回值

* **使用方法**

  ```python
  def decorator(f):
      def inner_func(para):
          print('{} begin...'.format(f.__name__))
          ret = f(para)
          print('{} end...'.format(f.__name__))
          return ret
      return inner_func
  
  @decorator  # It's equivalent to `do_something = decorator(do_sonmething(para))`
  
  def do_something(para):
      print('正在完成功能')
  
  if __name__ == '__main__':
      do_something(1)
  ```

* **带来的好处**

  * 不修改函数同时给函数增加一些附加功能，比如测运行时间并打印
  * 不改变函数调用方式
  * 代码精简

* **Note**：

  * 注意保存返回值
  * 注意多参数传递
    * `*args`  表示任意多个参数，是一个tuple
      * 调用的时候 `func(..., 1, 2, ...)`
    * `**kwargs`表示任意多个关键字参数，是一个dict
      * 调用的时候指明 `func(..., k1=1, k2 = 2,...)`
    * `*args`必须在`**kwargs`前面

* **装饰器带参数**

  * 参数传递是在 `@decorator(para1, para2, ...)`时传递的，比如`@lang('zh-cn')`

* **多层装饰器**

  * 使用方法就是在函数定义上方，使用多个`@decorator`，执行顺序按照定义的顺序，如：

    ```python
    @decorator_1
    @decorator_2
    def func():
    	return 0
    
    # It's equivalent to `decorator_1(decorator_2(func))`
    
    # 	enter decorator_1
    #	enter decorator_2
    #	func
    #	end decorator_2
    #	end decorator_1
    ```

    

* **类装饰器**

  ```python
  class class_name:
  	def __init__(self, v)
  	    self.__value__ = v
  		print('Instantiation')
  		
  	def __call__(self, f):
  		def inner_func(*args, **kwargs)
  			ret = f(*args, **kwargs)
  			return ret
  		return inner_func
  		
  @ class_name
  def func():
  	return 0
  	
  if __name__ == '__mian__'：
  	func()
  ```

  * 等价于实例化了一个`class_name`的类对象，并且调用了这个对象的`__call__(self, f)函数`， 也就是

  * ```
    A = class_name()
    func = A.__call__(func)
    ```

  * 

* **内置装饰器**

  * `@property`
  * `@setter`
  * `@deleter`

  这三者用来装饰类的实例方法，表明在类外可以获取、设置、删除类的某个属性，

  另外，只存在下面三种（三者修饰的函数需要同名）

  * `@property`：该属性只可读
  * `@property`, `@setter`：该属性可读可写
  * `@property`, `@setter`：该属性可读可写可删除

  

* `@classmethod`

  * 类方法装饰器

* ``@staticmethod`

  * 静态方法装饰器

### 异常处理

// TODO

### 作用域和命名空间

`if __name__=='__main__':` 只在该模块内可运行的代码段

### 编码问题

几种编码

* ASCII
  * 英文字符和一些符号
  * 1 byte 存储
* GB2312
  * 中国制定的编码规则
  * 2 byte 存储
* Unicode
  * 万国码
  * 2 byte 存储
  * 寻址索引方便，适合读取
* utf-8
  * 灵活 byte 存储(英文用 1 byte， 汉字用3 byte或更多等)
  * 存储方便，省内存

对应python中的`str`类，即文本总是Unicode编码，可以转为utf-8编码存道`byte`的二进制流里面

### 并发编程

##### 概念理解

* 并发 并行 串行
* 同步 异步
* 阻塞 非阻塞
* 进程 线程 协程

##### 协程

// TODO

##### 多线程

// TODO

##### 多进程

// TODO

### socket编程

// TODO
<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>