

* 二叉树各种遍历

* 排序

  * top K

    * 冒泡 $O(n*k)$

    * 堆（优先队列），$O(nlogk)$，对于特别大的数据量（大到不能一次性调入内存）适用

    * 不完全的快排/堆排，划分的时候舍弃用不到的一半（采用中位数算法选取主元，尽量使每次排除掉一半的无用信息）$O(n)$，但要修改原数组或者copy一份源数组。对于大数据量还要分别计算各自的Top k，再汇总，即加个$O(klog_2(N/B))$，$N$是总数据量，$B$是一次调入内存的数据量或每个节点的数据量

      ![image-20201216203611510](C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20201216203611510.png)

    * 对于特定的数据，分析，然后采用Hash的方法

  * 其他问题：和底层结构有关系，比较和读写的代价

* 

几大排序算法

稳定性：相同值元素的相对位置不变，写操作更少

就地：基本不需要辅助空间

对于数据项很大的排序操作，需要注重其写操作。

|      | 最好         | 最坏      | 空间            | 稳定性 | 写操作        | 其他                 |
| ---- | ------------ | --------- | --------------- | ------ | ------------- | -------------------- |
| 冒泡 | $O(n)$       | $O(n^2)$  | $O(1)$          |        |               |                      |
| 选择 | $O(n^2)$     | $O(n^2)$  | $O(1)$          |        | 严格$O(n)$    |                      |
| 插入 | $O(n)$       | $O(n^2)$  | $O(1)$          |        |               |                      |
| 希尔 | $O(n^{1.3})$ | $O(n^2)$  | $O(1)$          | ×      |               |                      |
| 堆排 | $O(nlgn)$    | $O(nlgn)$ | $O(nlgn)$       | **×**  |               |                      |
| 归并 | $O(nlgn)$    | $O(nlgn)$ | $O(n)$          |        | 严格$O(nlgn)$ | 链表结构可能快于快排 |
| 快排 | $O(nlgn)$    | $O(n^2)$  | $O(logn\sim n)$ | **×**  |               | 局部型好             |

c++ STL 的sort ：

* 数据量大就快排
* 递归太深就堆排
  * `depth_limit`
* 数据量很小就插排设置为了`__lg(last - first) * 2`即$2lgn$
* median-of - three （首尾中的中位数）作为 pivot



<img src="C:\Users\LLQ\AppData\Roaming\Typora\typora-user-images\image-20201216194637418.png" alt="image-20201216194637418" style="zoom:200%;" />





**高级算法**

* RBT
* AVL


<style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script><!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>